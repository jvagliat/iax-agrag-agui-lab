# Plan de Implementación Incremental: AGUI Oficial + agentic_rag_multi_query_bot

## Objetivo
Migrar `agentic_rag_multi_query_bot` desde implementación no oficial a **implementación oficial AGUI**, con desarrollo incremental y pruebas humanas en cada hito.

---

## Hito 1: Configuración Mínima Funcional (MVP)
**Objetivo**: Agente corriendo con AGUI oficial + test básico en frontend

### Tareas
1. **Instalar middleware oficial**
   ```bash
   poetry add adk-agui-middleware
   ```

2. **Crear archivo mínimo** `src/iax_agrag_agui_lab/run_agents_official.py`:
   ```python
   from fastapi import FastAPI, Request
   from adk_agui_middleware import SSEService, register_agui_endpoint
   from adk_agui_middleware.data_model.config import PathConfig
   from adk_agui_middleware.data_model.context import ConfigContext
   from agents.agrag.agentic_rag_multi_query import agentic_rag_multi_query_bot
   from ag_ui.core import RunAgentInput

   def extract_user_id(_: RunAgentInput, request: Request) -> str:
       return request.headers.get("X-User-Id", "guest")

   config = ConfigContext(
       app_name="agrag-official",
       user_id=extract_user_id
   )

   sse_service = SSEService(
       agent=agentic_rag_multi_query_bot,
       config_context=config
   )

   app = FastAPI(title="AGUI Official - AGRAG")

   register_agui_endpoint(
       app=app,
       sse_service=sse_service,
       path_config=PathConfig(agui_main_path="/agrag-official")
   )
   ```

3. **Ejecutar**:
   ```bash
   poetry run uvicorn src.iax_agrag_agui_lab.run_agents_official:app --port 2222 --reload
   ```

### Criterio de éxito
- ✅ Servidor levanta sin errores
- ✅ Endpoint `POST /agrag-official` responde
- ✅ Frontend conecta y recibe respuesta streaming básica

### Prueba humana
```
Pregunta: "¿Qué es iattraxia?"
Esperado: Respuesta del agente con formato SSE
```

---

## Hito 2: Historial de Conversaciones
**Objetivo**: Agregar soporte de hilos/threads persistentes

### Tareas
1. **Agregar `HistoryService`**:
   ```python
   from adk_agui_middleware import register_agui_history_endpoint
   from adk_agui_middleware.service.history_service import HistoryService
   from adk_agui_middleware.data_model.config import HistoryConfig

   def extract_session_id(request: Request) -> str:
       return str(request.path_params.get("thread_id"))

   history_service = HistoryService(
       HistoryConfig(
           app_name="agrag-official",
           user_id=lambda req: req.headers.get("X-User-Id", "guest"),
           session_id=extract_session_id
       )
   )

   register_agui_history_endpoint(app=app, history_service=history_service)
   ```

### Criterio de éxito
- ✅ `GET /threads` retorna lista de hilos
- ✅ `GET /threads/{thread_id}/messages` muestra historial
- ✅ Frontend mantiene conversación multi-turno

### Prueba humana
```
1. Pregunta: "¿Qué es IAX?"
2. Pregunta: "¿Y qué agentes tiene?"
   Esperado: El agente recuerda contexto previo
```

---

## Hito 3: Estado de Sesión Persistente
**Objetivo**: Guardar/restaurar estado del agente entre mensajes

### Tareas
1. **Agregar `StateService`**:
   ```python
   from adk_agui_middleware import register_state_endpoint
   from adk_agui_middleware.service.state_service import StateService
   from adk_agui_middleware.data_model.config import StateConfig

   state_service = StateService(
       StateConfig(
           app_name="agrag-official",
           user_id=lambda req: req.headers.get("X-User-Id", "guest"),
           session_id=extract_session_id
       )
   )

   register_state_endpoint(app=app, state_service=state_service)
   ```

2. **Verificar estado inicial** (keys usadas por agente):
   ```python
   # El agente usa estos output_keys:
   # - TriageAgent.response
   # - QueryGeneratorAgent.generated_queries
   # - MultiRetrievalAgent.retrieved_chunks
   # - MultiRetrievalAgent.final_response
   ```

### Criterio de éxito
- ✅ `GET /threads/{thread_id}/state` retorna estado del agente
- ✅ `PATCH /threads/{thread_id}/state` actualiza valores
- ✅ Frontend visualiza estado (queries generadas, chunks retrieved)

### Prueba humana
```
1. Pregunta específica: "¿Cómo funciona el sistema de agentes en IAX?"
2. GET /threads/{id}/state → verificar presence de:
   - QueryGeneratorAgent.generated_queries (array de 3 queries)
   - MultiRetrievalAgent.retrieved_chunks (chunks RAG)
```

---

## Hito 4: Multi-Usuario Dinámico
**Objetivo**: Soportar múltiples usuarios simultáneos

### Tareas
1. **Implementar extractor dinámico de usuario**:
   ```python
   def extract_user_id_from_header(_: RunAgentInput, request: Request) -> str:
       user = request.headers.get("X-User-Id")
       if not user:
           raise ValueError("Header X-User-Id requerido")
       return user

   config = ConfigContext(
       app_name="agrag-official",
       user_id=extract_user_id_from_header  # Ahora obligatorio
   )
   ```

2. **Actualizar frontend** para enviar `X-User-Id` en requests

### Criterio de éxito
- ✅ Usuario A y B pueden tener conversaciones independientes
- ✅ Hilos de cada usuario no se mezclan
- ✅ GET /threads retorna solo hilos del usuario actual

### Prueba humana
```
Navegador 1 (User: alice):
  - Pregunta: "¿Qué es iattraxia?"

Navegador 2 (User: bob):
  - Pregunta: "¿Qué es IAX?"

Verificar: GET /threads con X-User-Id: alice → solo hilo de alice
```

---

## Hito 5: CORS y Middleware de Producción
**Objetivo**: Configuración lista para despliegue

### Tareas
1. **Agregar CORS configurable**:
   ```python
   from starlette.middleware.cors import CORSMiddleware
   import os

   app.add_middleware(
       CORSMiddleware,
       allow_origins=os.getenv("ALLOWED_ORIGINS", "http://localhost:3000").split(","),
       allow_credentials=True,
       allow_methods=["GET", "POST", "PATCH", "DELETE", "OPTIONS"],
       allow_headers=["*"],
   )
   ```

2. **Agregar logging estructurado**:
   ```python
   import logging
   logging.basicConfig(level=logging.INFO)
   ```

3. **Crear `.env.example`** con variables necesarias

### Criterio de éxito
- ✅ Frontend de producción puede conectar (CORS configurado)
- ✅ Logs muestran requests/responses
- ✅ Variables de entorno documentadas

---

## Hito 6: Feature Parity con Implementación No Oficial
**Objetivo**: Equivalencia funcional completa

### Tareas
1. **Agregar formateador de lista de hilos**:
   ```python
   async def format_thread_list(session_list) -> list[dict]:
       return [
           {
               "threadId": s.id,
               "lastUpdateTime": str(int(s.last_update_time)),
               "threadTitle": s.state.get("threadTitle", "Nueva conversación")
           }
           for s in session_list
       ]

   history_service = HistoryService(
       HistoryConfig(..., get_thread_list=format_thread_list)
   )
   ```

2. **Documentar diferencias** con implementación no oficial

### Criterio de éxito
- ✅ Misma UX que implementación no oficial
- ✅ Todos los endpoints funcionan igual
- ✅ Documentación de migración lista

---

## Resumen de Hitos

| Hito | Features | LOC ~aprox | Tiempo estimado | Dependencias |
|------|----------|-----------|-----------------|--------------|
| **1. MVP** | SSE básico | 30 | 30 min | ninguna |
| **2. Historial** | GET threads/messages | +20 | 20 min | Hito 1 |
| **3. Estado** | GET/PATCH state | +15 | 15 min | Hito 2 |
| **4. Multi-user** | X-User-Id dinámico | +10 | 20 min | Hito 3 |
| **5. Producción** | CORS, logs, .env | +15 | 15 min | Hito 4 |
| **6. Feature parity** | Thread formatting | +10 | 10 min | Hito 5 |
| **TOTAL** | Completo | ~100 LOC | ~2 horas | - |

---

## Estrategia de Pruebas

### Por hito
- **Manual**: Test con curl/Postman después de cada hito
- **Frontend**: Conectar y probar interacción humana
- **Rollback**: Mantener implementación no oficial activa hasta validar oficial

### Frontend test checklist
- [ ] Mensaje enviado → respuesta streaming visible
- [ ] Nuevo hilo creado automáticamente
- [ ] Historial persiste entre recargas
- [ ] Multi-turno funciona (contexto previo)
- [ ] Múltiples usuarios no interfieren

---

## Comandos de Test

```bash
# Hito 1: Test SSE endpoint
curl -X POST http://localhost:2222/agrag-official \
  -H "Content-Type: application/json" \
  -d '{"messages": [{"role": "user", "content": "Hola"}]}'

# Hito 2: Test historial
curl http://localhost:2222/threads -H "X-User-Id: testuser"

# Hito 3: Test estado
curl http://localhost:2222/threads/{thread_id}/state -H "X-User-Id: testuser"

# Hito 4: Test multi-usuario
curl http://localhost:2222/threads -H "X-User-Id: alice"
curl http://localhost:2222/threads -H "X-User-Id: bob"
```

---

## Próximos Pasos
1. Ejecutar **Hito 1** completo
2. Validar con frontend antes de avanzar
3. Documentar diferencias encontradas vs implementación no oficial
4. Iterar hitos 2-6 secuencialmente
